Research Journal for the Week of an October 22nd Meeting:

Mod pi problem:
    Some preliminary tests showed that in fact the mod \pi problem was not resolved by the modifications to the expectation step alone. When these fixes were enabled, the jets were qualitatively different, and tests run on a set of three particles straddling the 2 pi boundary found that jets moved towards the center of the event.
    I concluded that this issue was being caused because despite the probabilities now being calculated at least approximately correctly, the jets were still "pulling" in the wrong directions, because we were taking the average of particle.\phi for each particle, which always ranges between 0 and 2*\pi, and which does not necessarily satisfy |particle.\phi - cluster.\phi| < \pi.
    A first step towards resolving this issue was to introduce similar conditional branches into the calculation of the new cluster \phi as were introduced into the expectation calculations: let each particle pull the jet along the shortest direction around the calorimeter, so that |particle.\phi - cluster_old.\phi| < \pi. This can always be accomplished by adding 2*\pi if particle.\phi < cluster_old.\phi and -2*pi otherwise, unless this condition is already satisfied.
    With this fix in place, it was clear that the algorithm was computing the right cluster locations, but the jets were still merging on the three particle test case that Ben and I choose to test the fixes. After some thought, I proposed that this was due to the way that the sigma update step was performed. Particles on the opposite sides of the calorimeter add highly to the variance because a jet near the 2*\pi boundary has many of its constituents with |delta_\phi| large, adding disproportionately to the "variance" sum used to update \Sigma. The fix was ever so slightly different here depending on the case, but ultimately introducing a conditional for each particle for each contribution to each jet to take the shortest direction around the calorimeter appears to have worked. Final results on the test case are documented in mod_pi_prefix.tar and mod_pi_postfix.tar in the archives folder, which show that the correct behavior is obtained in each case. Similar results on full events can be found in archives/large_{postfix/prefix}.tar.
    A final note on performance: most of the fixes are not in especially tight loops, the tightest having already been encountered when the E step was fixed. However, I expect that we will see some slowdown as a result of these modifications, but there is not much that can be done to resolve that, because this is already a much cheaper solution to the problem than introducing a wrapped Gaussian.
    Overall, because all of the changes are wrapped inside a conditional whose support is the complement of a region with width 2*\pi, in the limit \pi\rightarrow\infty this is necessarily the same method as without the fix. However, the changes to doGaus do not have this property. Here though the modification is suppressed by e^-(delta)^2, and delta = O(\pi) in the limit \pi\rightarrow\infty, so we once again recover the same behavior.

Inverse Efficiency plots:
    Inverse efficiency plots (signal efficiency vs 1/background efficiency) are now generated by default along with signal efficiency vs 1 - background efficiency plots. Might have to play around with the location of the legend a little bit. Also axis locations aren't perfect. Also the naming is programatically done by prefixing "inv_" to the plot name. Meh.
           
Area/mass/sigma disrimination:
    Made efficiency plots including the trimmed area, trimmed mass/pT, area+mass/pT, and area+sigma. These will be in all future versions of the code. I was surprised how strong mass/pT by itself was, as it performed as well or better than all the others with the same number of total bins. Would like to run with higher statistics, but this was making it hard to understand the relationship between area and sigma. One plausible explanation is that because we are currently testing with no pileup, the results are *very* sharp for this variable, or at least much sharper than we could expect in actuality. 

Things to bring up in meeting
    New displays showing that the fix works. Discussion of how both the E and M step must be modified in order to adequately resolve the mod 2*\pi problem.
